# 33. 搜索旋转排序数组

## 题目描述

整数数组 `nums` 按升序排列，数组中的值互不相同。

在传递给函数之前，`nums` 在预先未知的某个下标
`k`（`0 <= k < nums.length`）上进行了旋转，使数组变为
`[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`。

给你旋转后数组 `nums` 和一个整数 `target`，如果 `nums` 中存在这个目标值
`target`，则返回它的下标，否则返回 `-1`。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

## 示例

**示例 1：**

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

**示例 2：**

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

**示例 3：**

```
输入: nums = [1], target = 0
输出: -1
```

## 提示

- `1 <= nums.length <= 5000`
- `-10⁴ <= nums[i] <= 10⁴`
- `nums` 中的所有值互不相同
- `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转
- `-10⁴ <= target <= 10⁴`
